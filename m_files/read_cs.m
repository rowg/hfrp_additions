function  dat = read_cs(filename,rcIdx,vb)disp('renamed this to cs_read.m')keyboard% READ CS - CODAR cross spectra file reader% DAT = ReadCS(filename,rc,vb);%% INPUT:% filename	- Input Cross Spectra file name as an ASCII string%			  e.g. 'CSA OSU2 97/05/20 1200'% rcIdx     - optional array of range cells indecies to load%             (eg 1, 24, [5 9:12], etc)% vb        - verbosity switch ('true' or 'false' logical if used as%               2nd input)%% OUTPUT% DAT data structure containing:%% DAT.Header substructure:%	dateTimeSec04		- Date/Time of data in seconds since 1/1/1904%	kindOfData			- Kind of data %							=1 => Unaveraged cross spectra%							=2 => Averaged cross spectra%	siteStr				- Site designation (4 characters), e.g. 'PPin'%	averagingTimeMin	- Averaging time in minutes (default 60 min)%	freqMHz				- Frequency in MHz (default 12 MHz)%	SwRfreqHz			- Sweep repetition frequency in Hz (default 2 Hz)%	SwBWkHz				- Sweep bandwidth in kHz (default 50 kHz)%	sweepUpDown			- Sweep up(=True) or down(=False) (default False)%	nRangeCells			- Number of range cells %						     (default 32 for unaveraged, 31 for averaged)%	firstRangeCell		- First range cell (default 0)%	distToFirstRangeCell- Distance to first range cell in km%% CROSS SPECTRA DATA%   They are matrices with size [nFFT,nRangeCells]%	antenna1Self		- Antenna#1 self spectra %	antenna2Self		- Antenna#2 self spectra %	antenna3Self		- Antenna#3 self spectra %	antenna12CrossSp	- Antenna#1*conj(Antenna#2)) cross spectra (complex)%	antenna13CrossSp	- Antenna#1*conj(Antenna#3)) cross spectra (complex)%	antenna23CrossSp	- Antenna#2*conj(Antenna#3)) cross spectra (complex)%	spectraQualNum		- Spectral quality numbers (0.0 to 1.0) these are used %						  only with the averaged cross spectra. They represent%						  the fraction of unaveraged spectral values removed at%						  bin over the (hour) averaging period due to ship or%						  interference rejection procedures.%						- If this number drops below 0.5 (50%), a minus sign%						  is placed in front of 'antenna3Self' as a flag to%						  suggest this bin not be used for subsequent processing%						  because the data is too stale.  The minus can be ignored.%% EXAMPLE% >> fn = '/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_205124.cs';% >> dat = read_cs(fn); %%% NOTES% includes an optional test case invoked as follows:% >> dat = read_cs('--t');% Modified from COS's ReadCS.m by Brian Emery. % Copyright probably still applies .... %% Original by   Jimmy Isaacson%  jimmy@codaros.com%% April 2011 Major mods by Brian Emery (renamed read_cs.m):%   - added ability to load selection of range cells%   - lots of refactoring (to divide + (hopefully) conquer)%   - added robust test cases     % NOTES% float32 is 4 Bytes per element, we load 9 range cells by default, % with nfft length (usually 512) elements, 9*512*4 = 18432 Bytes per % range cell% TO DO% expand to CSS and CSA (averaged) filesif nargin < 3, vb = 0; end% optional test caseif strcmp(filename,'--t'), test_case, dat =[]; return, end% Recurse if filename is multi-element cell input% needs preallocation, rcIdx optionalif iscell(filename)    for i = 1:numel(filename)          dat(i) = read_cs(filename{i},rcIdx,vb);           end    returnend% Open file read onlyfid=fopen(filename,'r','b'); % Read in header data[Header,nfft,nRangeCells] = read_header(fid);%--------------------------------------------------------------------------------% INITIALIZE%--------------------------------------------------------------------------------% Init output matricies and position file pointer if necessary    % If range cells list given, re-determine number of range cells to loadif nargin > 1 && ~islogical(rcIdx)    nRangeCells = length(rcIdx);         end% Setup and zero out matrices[antenna1Self, antenna2Self, antenna3Self,  ...    antenna12CrossSp, antenna13CrossSp, antenna23CrossSp, ...        spectraQualNum ] =  deal(zeros(nfft,nRangeCells));%--------------------------------------------------------------------------------% Read in cross spectra data%--------------------------------------------------------------------------------% Begin loopfor rc = 1:nRangeCells        % only use fseek if reading subset of data    if nargin > 1 && ~islogical(rcIdx)                        % position pointer (-1 = begining of file)        s = fseek(fid, 72 + ((rcIdx(rc)-1)*9*4*nfft) ,-1);                % catch errors in fseek and rcIdx        pointer_err_chk(s)            end                % Read in self spectra data    antenna1Self(:,rc) = fread(fid,nfft,'float32');      antenna2Self(:,rc) = fread(fid,nfft,'float32');     antenna3Self(:,rc) = fread(fid,nfft,'float32');         % Read in cross spectra data; real and imaginary seperately    antenna12CSp = fread(fid,[2,nfft],'float32')';     antenna13CSp = fread(fid,[2,nfft],'float32')';     antenna23CSp = fread(fid,[2,nfft],'float32')';         % Combine real and imaginary cross spectra data    antenna12CrossSp(:,rc) = antenna12CSp(:,1)+1i*antenna12CSp(:,2);    antenna13CrossSp(:,rc) = antenna13CSp(:,1)+1i*antenna13CSp(:,2);    antenna23CrossSp(:,rc) = antenna23CSp(:,1)+1i*antenna23CSp(:,2);        % If averaged data, read in spectral quality numbers    if Header.kindOfData == 2                spectraQualNum(:,rc)=fread(fid,nfft,'float32');                % Byte count will change if using averaged data        % ... I think the 9 gets changed to a 10 ...        warning('codar:read_cs','Byte count may change!')            endend% Close filestatus = fclose(fid);if status ~= 0    error(error_messages(7))end%--------------------------------------------------------------------------------% Finalize Outputs%--------------------------------------------------------------------------------% Pack data into structurevars ={'Header','antenna1Self','antenna2Self','antenna3Self', ...       'antenna12CrossSp','antenna13CrossSp','antenna23CrossSp','spectraQualNum'};   dat = struct_pack(vars);% inform user if verbosity if vb, disp(['loaded ' filename]), end% keep range cell index if only a subset of dataif nargin > 1 && ~islogical(rcIdx)   dat.rCellIdx = rcIdx; endend% ----------------------------------------------function pointer_err_chk(s)% POINTER ERR CHK% catch errors in fseek and rcIdx if s < 0    [mess,errnum] = ferror(fid);    error(errnum,mess)endend% ----------------------------------------------function [H,fftLength,nRangeCells] = read_header(fid)% READ HEADER %  Read in header data% hex2dec is slow, convert once but keep around for reference% these are the 'number of Bytes until data'curVersNo=4;curNbytesA = 62; % hex2dec('3E');curNbytesB = 56; % hex2dec('38');curNbytesC = 48; % hex2dec('30');curNbytesD = 0;  % hex2dec('00');rdCSErr = 0;% Read in specific header data (Order dependent)versNo = fread_chk(fid,'int16',curVersNo,1);dTHex = fread(fid,4,'uchar');dateTimeSec04=dTHex(4)+dTHex(3)*256+dTHex(2)*(256^2)+dTHex(1)*(256^3); NbytesA = fread_chk(fid,'int32',curNbytesA,2);kindOfData = fread_chk(fid,'int16',2,3,@gt);NbytesB = fread_chk(fid,'int32',curNbytesB,4);siteStr = setstr(fread(fid,4,'uchar'))';NbytesC = fread_chk(fid,'int32',curNbytesC,5);averagingTimeMin = fread(fid,1,'int32');deleteRawSpectra = fread(fid,1,'int32');overrideRemHeader = fread(fid,1,'int32');freqMHz = fread(fid,1,'float32');SwRfreqHz = fread(fid,1,'float32');SwBWkHz = fread(fid,1,'float32');sweepUpDown = fread(fid,1,'int32');fftLength = fread(fid,1,'int32');nRangeCells = fread(fid,1,'int32');firstRangeCell = fread(fid,1,'int32');distToFirstRangeCell = fread(fid,1,'float32');NbytesD = fread_chk(fid,'int32',curNbytesD,6);% Get variables list and pack them into a structurehflds = {'dateTimeSec04','kindOfData','siteStr','averagingTimeMin', ...    'freqMHz','SwRfreqHz','SwBWkHz','sweepUpDown','nRangeCells', ...    'firstRangeCell','distToFirstRangeCell','dTHex','deleteRawSpectra',...    'overrideRemHeader'};H = struct_pack(hflds);end% ----------------------------------------------function versNo = fread_chk(fid,type,testVal,errNum,fxn)% FREAD CHECK - file read with error checking%% Replaces, for example:% versNo=fread(fid,1,'int16');% if versNo ~= curVersNo%   rdCSErr=1;%   disp('return at line 76'),return%   %   error(ERR(1))%   % end% Set test function to 'not isequal' by defaultif nargin < 5, fxn = @not_is_equal; end% Data fields to read fixed at 1versNo = fread(fid,1,type);if fxn(versNo,testVal)    error(error_messages(errNum))endend% ----------------------------------------------function tf = not_is_equal(a,b)tf = not(isequal(a,b));end% ----------------------------------------------function ERR = error_messages(n)% ERROR MESSAGES% get error message structure%% =  0 => No error% =  1 => Bad Version Number% =  2 => Header field 3 not correct% =  3 => Kind of data (field 4) not =1,2% =  4 => Header field 5 not correct% =  5 => Header field 7 not correct% =  6 => Header field 19 not correct% =  7 => File close errorERR(1).msgid   = 'codar:read_cs:bad_version_number';ERR(1).message = 'Input file is an invalid version or type.';ERR(2).msgid   = 'codar:read_cs:bad_header_field';ERR(2).message = 'Header field 3 not correct.';ERR(3).msgid   = 'codar:read_cs:bad_kind_of_data';ERR(3).message = 'Kind of data (field 4) not = 1 or 2.';ERR(4).msgid   = 'codar:read_cs:bad_header_field';ERR(4).message = 'Header field 5 not correct.';ERR(5).msgid   = 'codar:read_cs:bad_header_field';ERR(5).message = 'Header field 7 not correct.';ERR(6).msgid   = 'codar:read_cs:bad_header_field';ERR(6).message = 'Header field 19 not correct.';ERR(7).msgid   = 'codar:read_cs:bad_file_close';ERR(7).message = 'File close error.';ERR = ERR(n);end% ----------------------------------------------function check_flds(dat,old)% Some code to verify that the data is the same% % if rCellIdx is present, it will check that % a subset of range cells from the old data is the% same as the subset of new data.% Check the headerif ~isequal(dat.Header,old.Header)    disp('difference between read_cs and ReadCS.m HEADERS detected')    keyboardend% Get fields except for the Headerfld = setdiff(fieldnames(old),'Header');% get indexingif isfield(dat,'rCellIdx')    rx = dat.rCellIdx;else    rx = ':';end% Run the checkfor i = 1:numel(fld)        if ~isequal(dat.(fld{i}),old.(fld{i})(:,rx))        disp('difference between read_cs and ReadCS.m detected')        keyboard    end    end% if we get here all the test passeddisp('TESTS PASSED')end% ----------------------------------------------function test_case% TEST CASE for read_cs.m%% datestr(datenum(1904,1,1)+(dateTimeSec04/86400))% Get cs test filenamefn = '/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_205124.cs';  % fn = {'/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_205124.cs'; ...%       '/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_203836.cs'; ...	%       '/Data/testData/compute_apm_from_csq/CSQ_sci1_10_09_01_000351.cs'; ...%       '/Data/testData/compute_apm_from_csq/CSQ_cop1_08_12_06_204252.cs';}% fn = '/Data/testData/simulatedArchive/ssd1/CSS/2008_01/31/CSS_ssd1_08_01_31_1000.cs4'; keyboard% RUN BASIC TEST% Load all data, compare old and new output to verify dat = read_cs(fn); %keyboard% get ReadCS output for comparisonold = ReadCS(fn);% remove rdCSErr fieldold = rmfield(old,'rdCSErr');% check all is samecheck_flds(dat,old)% RUN COMPLEX TEST% Now load subset of range cells and see how they comparerc = [5:6 15] ;dat = read_cs(fn,rc); % check all is samecheck_flds(dat,old)% Make figuresfor i = 1:numel(rc)        figure    % Plot ReadCS data    plot(1:512,real(10*log10(old.antenna12CrossSp(:,rc(i)))),'-r'), hold on        % Plot subset'd data    plot(1:512,real(10*log10(dat.antenna12CrossSp(:,i))),'b.')endkeyboardend